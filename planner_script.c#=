using System;
using System.Collections;
using System.Collections.Generic;

using Rhino;
using Rhino.Geometry;

using Grasshopper;
using Grasshopper.Kernel;
using Grasshopper.Kernel.Data;
using Grasshopper.Kernel.Types;

using System.IO;
using System.Linq;
using System.Data;
using System.Drawing;
using System.Reflection;
using System.Windows.Forms;
using System.Xml;
using System.Xml.Linq;
using System.Runtime.InteropServices;

using Rhino.DocObjects;
using Rhino.Collections;
using GH_IO;
using GH_IO.Serialization;

/// <summary>
/// This class will be instantiated on demand by the Script component.
/// </summary>
public class Script_Instance : GH_ScriptInstance
{
#region Utility functions
  /// <summary>Print a String to the [Out] Parameter of the Script component.</summary>
  /// <param name="text">String to print.</param>
  private void Print(string text) { /* Implementation hidden. */ }
  /// <summary>Print a formatted String to the [Out] Parameter of the Script component.</summary>
  /// <param name="format">String format.</param>
  /// <param name="args">Formatting parameters.</param>
  private void Print(string format, params object[] args) { /* Implementation hidden. */ }
  /// <summary>Print useful information about an object instance to the [Out] Parameter of the Script component. </summary>
  /// <param name="obj">Object instance to parse.</param>
  private void Reflect(object obj) { /* Implementation hidden. */ }
  /// <summary>Print the signatures of all the overloads of a specific method to the [Out] Parameter of the Script component. </summary>
  /// <param name="obj">Object instance to parse.</param>
  private void Reflect(object obj, string method_name) { /* Implementation hidden. */ }
#endregion

#region Members
  /// <summary>Gets the current Rhino document.</summary>
  private readonly RhinoDoc RhinoDocument;
  /// <summary>Gets the Grasshopper document that owns this script.</summary>
  private readonly GH_Document GrasshopperDocument;
  /// <summary>Gets the Grasshopper script component that owns this script.</summary>
  private readonly IGH_Component Component;
  /// <summary>
  /// Gets the current iteration count. The first call to RunScript() is associated with Iteration==0.
  /// Any subsequent call within the same solution will increment the Iteration count.
  /// </summary>
  private readonly int Iteration;
#endregion

  /// <summary>
  /// This procedure contains the user code. Input parameters are provided as regular arguments,
  /// Output parameters as ref arguments. You don't have to assign output parameters,
  /// they will have a default value.
  /// </summary>
  private void RunScript(bool iReset, Mesh iMeshBody, List<Mesh> iMeshHead, List<Mesh> iMeshShadow, Point3d iTarget, List<Point3d> iObstacles, double iMaxSpeed, ref object A)
  {


    BB8.Obstacles = iObstacles;
    BB8.Target = iTarget;
    BB8.MaxSpeed = iMaxSpeed;

    if (iReset || bb8 == null)
    {
      //==========================================================
      // Load external files
      //==========================================================

      string folder = GrasshopperDocument.FilePath;
      folder = folder.Substring(0, folder.LastIndexOf(@"\"));

      BB8.Sounds = new System.Media.SoundPlayer[7];
      for (int i = 0; i < 7; i++)
        BB8.Sounds[i] = new System.Media.SoundPlayer(folder + @"\Sound\BB8-" + i + ".wav");

      BB8.MatBody = new Rhino.Display.DisplayMaterial();
      BB8.MatBody.Diffuse = Color.White;
      BB8.MatBody.Ambient = Color.Gray;
      BB8.MatBody.SetBitmapTexture(folder + @"\Textures\Body diff MAP.jpg", true);

      BB8.MatShadow = new Rhino.Display.DisplayMaterial[2];
      BB8.MatShadow[0] = new Rhino.Display.DisplayMaterial();
      BB8.MatShadow[0].Diffuse = Color.Black;
      BB8.MatShadow[0].Ambient = Color.Black;
      BB8.MatShadow[0].SetTransparencyTexture(folder + @"\Textures\Shadow.jpg", true);
      BB8.MatShadow[1] = new Rhino.Display.DisplayMaterial();
      BB8.MatShadow[1].Diffuse = Color.Black;
      BB8.MatShadow[1].Ambient = Color.Black;
      BB8.MatShadow[1].SetTransparencyTexture(folder + @"\Textures\BottomAmbientShadow.jpg", true);

      BB8.MatHead = new Rhino.Display.DisplayMaterial[9];
      for (int i = 0; i < 9; i++)
      {
        BB8.MatHead[i] = new Rhino.Display.DisplayMaterial();
        BB8.MatHead[i].Diffuse = Color.White;
        BB8.MatHead[i].Ambient = Color.Gray;
      }

      BB8.MatHead[0].SetBitmapTexture(folder + @"\Textures\white dirt map.jpg", true);
      BB8.MatHead[1].SetBitmapTexture(folder + @"\Textures\wildtextures-metal-sheet-scratched-brushed.jpg", true);
      BB8.MatHead[5].SetBitmapTexture(folder + @"\Textures\Head ring diff MAP.jpg", true);
      BB8.MatHead[6].SetBitmapTexture(folder + @"\Textures\head top diff MAP.jpg", true);
      BB8.MatHead[7].SetBitmapTexture(folder + @"\Textures\HEAD diff MAP.jpg", true);

      BB8.MatHead[2].Diffuse = Color.FromArgb(30, 30, 30);
      BB8.MatHead[3].Diffuse = Color.FromArgb(5, 5, 5);
      BB8.MatHead[4].Diffuse = Color.FromArgb(220, 220, 220);

      BB8.MatHead[2].Ambient = BB8.MatHead[3].Ambient = BB8.MatHead[4].Ambient = Color.Black;
      BB8.MatHead[3].Specular = Color.White;
      BB8.MatHead[3].Shine = 0.8;

      BB8.MatHead[8].Diffuse = Color.Black;
      BB8.MatHead[8].Ambient = Color.Black;
      BB8.MatHead[8].SetTransparencyTexture(folder + @"\Textures\NeckAmbientShadow.jpg", true);

      BB8.MatRebelCrest = new Rhino.Display.DisplayMaterial();
      BB8.MatRebelCrest.Diffuse = Color.Red;
      BB8.MatRebelCrest.Ambient = Color.Red;
      BB8.MatRebelCrest.Emission = Color.Red;
      BB8.MatRebelCrest.SetTransparencyTexture(folder + @"\Textures\RebelCrest.jpg", true);
      BB8.MatRebelCrest.Transparency = 0.0;


      //==========================================================
      // Initialize new bb8 object
      //==========================================================

      bb8 = new BB8(Point3d.Origin);
      bb8.MeshBody = iMeshBody;
      bb8.MeshShadow = iMeshShadow.ToArray();
      for (int i = 0; i < iMeshHead.Count; i++)
      {
        bb8.MeshHeadOriginal[i] = iMeshHead[i];
        bb8.MeshHead[i] = iMeshHead[i];
      }

      bb8.PlaySound();
    }

    bb8.Step();

    A = new Point3d(200, 200, 0);

    //oCurrentFrame = bb8.Frame;


  }

  // <Custom additional code> 


  private BB8 bb8;


  public override void DrawViewportMeshes(IGH_PreviewArgs args)
  {
    base.DrawViewportMeshes(args);
    bb8.DrawPreviewMeshes(args);
  }

  class BB8
  {
    public static RhinoDoc RhinoDocument;
    public static GH_Document GrasshopperDocument;

    public static List<Point3d> Obstacles;
    public static Point3d Target;
    public static double Timestep = 0.001;
    public static double MaxSpeed = 100;
    public static Random Random = new Random();
    public static System.Media.SoundPlayer[] Sounds;
    public static System.Diagnostics.Stopwatch SoundStopwatch = System.Diagnostics.Stopwatch.StartNew();
    public static System.Diagnostics.Stopwatch Stopwatch = new System.Diagnostics.Stopwatch();

    public static Rhino.Display.DisplayMaterial MatBody;
    public static Rhino.Display.DisplayMaterial[] MatShadow;
    public static Rhino.Display.DisplayMaterial[] MatHead;
    public static Rhino.Display.DisplayMaterial MatRebelCrest;

    //============================================================================

    public Point3d Position;
    public Vector3d Velocity;

    private Vector3d look = Vector3d.XAxis;
    private int stepCount = 0;
    private double t = 0;

    private bool targetReached = false;

    public Mesh MeshBody;
    public Mesh[] MeshHeadOriginal;
    public Mesh[] MeshHead;
    public Mesh[] MeshShadow;
    private static Mesh MeshRebelCrest;

    static BB8()
    {
      MeshRebelCrest = new Mesh();
      double d = 0.2;
      MeshRebelCrest.Vertices.Add(new Point3d(-d, -d, 0.0));
      MeshRebelCrest.Vertices.Add(new Point3d(d, -d, 0.0));
      MeshRebelCrest.Vertices.Add(new Point3d(d, d, 0.0));
      MeshRebelCrest.Vertices.Add(new Point3d(-d, d, 0.0));
      MeshRebelCrest.Faces.AddFace(0, 1, 2, 3);
      MeshRebelCrest.TextureCoordinates.Add(0.0, 0.0);
      MeshRebelCrest.TextureCoordinates.Add(1.0, 0.0);
      MeshRebelCrest.TextureCoordinates.Add(1.0, 1.0);
      MeshRebelCrest.TextureCoordinates.Add(0.0, 1.0);
    }


    public BB8(Point3d initialPosition)
    {
      Position = initialPosition;
      Velocity = Vector3d.Zero;
      stepCount = 0;

      MeshHeadOriginal = new Mesh[9];
      MeshHead = new Mesh[9];

      Stopwatch = new System.Diagnostics.Stopwatch();
    }



    public void Step()
    {
      if (stepCount == 0)
      {
        t = 0.0;
        Stopwatch.Restart();
      }

      double deltaT = Stopwatch.Elapsed.TotalSeconds - t;
      t = Stopwatch.Elapsed.TotalSeconds;

      stepCount++;

      Vector3d targetVelocity = Vector3d.Zero;
      Point3d target = new Point3d(Target.X, Target.Y, 0.0);
      Vector3d toTarget = target - Position;

      // Avoid obstacle =======================================================================

      foreach (Point3d obstacle in Obstacles)
      {
        Vector3d getAway = Position - obstacle;
        double d = getAway.Length;
        double r = 3.0;
        if (d > r) continue;

        // The getAway vector will be perpendicular to the vector pointing toward to the obstacle
        // The magnitude of of getAway will get larger as BB8 gets closer to the obstacle's center

        getAway.Unitize();
        getAway = 300 / (d * 0.3) * (Vector3d.CrossProduct(-getAway, toTarget).Z > 0.0 ?
          new Vector3d(getAway.Y, -getAway.X, 0) :
          new Vector3d(-getAway.Y, getAway.X, 0));


        targetVelocity += getAway;
      }

      double k = 0.4; // this is the ratio that will be used to blend the targetVelocity with the current velocity. This is a way to have some nice acceleration/deceleration

      double arrivalRange = 0.2 + 0.3 * (MaxSpeed - 50.0) / 150.0;

      if (toTarget.Length > arrivalRange)
      {
        toTarget *= 500 / toTarget.Length;
        targetVelocity += toTarget;

        // Slightly swing the targetVelocity sideway so that BB8 wiggles sideway a bit on his way to the target. This makes his motion a bit more organic.
        targetVelocity.Rotate(0.2 * Math.Cos(t * MaxSpeed * 0.08), Vector3d.ZAxis);

        targetReached = false;
      }
      else // Slow BB8 down he is within the target's range
      {
        targetVelocity = Vector3d.Zero;
        k = 0.000002;
        if (!targetReached) PlaySound();
        targetReached = true;
      }

      // Idle move =======================================================================

      // Here we add a small vector whose magnitude occilates between -1.5 and +1.5 in the X and Y direction
      // This will makes BB8 slighty swing his position back and forth (and sideway) which looks nice when he is idle

      targetVelocity +=
        Vector3d.XAxis * 1.5 * Math.Cos(t * 1) +
        Vector3d.YAxis * 1.5 * Math.Sin(t * 0.73);

      // Blend the current velocty with the targetVelocity =========================================================================================

      if (targetVelocity.Length > MaxSpeed * 100) targetVelocity *= MaxSpeed * 100 / targetVelocity.Length;

      k = Math.Pow(k, deltaT);
      Velocity = k * Velocity + (1.0 - k) * targetVelocity;


      // Update the position based the blended velocity vector above ======================================================================

      if (Velocity.Length > MaxSpeed) Velocity *= MaxSpeed / Velocity.Length;
      Vector3d move = Velocity * Timestep;

      if (move.Length > 0.0001)
      {
        Position += move;

        MeshBody.Translate(move);
        MeshBody.Rotate(move.Length * 2.0, new Vector3d(-Velocity.Y, Velocity.X, 0.0), new Point3d(Position.X, Position.Y, 0.25));

        MeshShadow[0].Translate(move);
        MeshShadow[1].Translate(move);
      }

      // Turn the head so BB8 looks at the target ==================================================================================

      if (toTarget.Length > 0.3)
      {
        toTarget.Unitize();
        double turn = Vector3d.VectorAngle(look, toTarget, Plane.WorldXY);
        if (turn > Math.PI) turn -= Math.PI * 2.0;
        else if (turn < -Math.PI) turn += Math.PI * 2.0;
        look.Rotate(deltaT * 4 * turn, Vector3d.ZAxis);
        look.Unitize();
      }

      // Idle head rotation ========================================================================

      Plane headFrame = new Plane(Position, look, new Vector3d(-look.Y, look.X, 0.0));

      headFrame.Rotate(0.6 * Math.Sin(t), headFrame.ZAxis,
        new Point3d(Position.X, Position.Y, 0.25));

      headFrame.Rotate(0.05 + 0.1 * Math.Cos(t / 0.7), headFrame.YAxis,
        new Point3d(Position.X, Position.Y, 0.25));

      headFrame.Rotate(0.01 * Math.Cos(t * 0.31) + 0.01 * Math.Cos(t * 0.27) + 0.01 * Math.Sin(t * 0.17), headFrame.XAxis,
        new Point3d(Position.X, Position.Y, 0.25));


      // Tilt head forward while moving ========================================================================

      Transform headTransform = Transform.PlaneToPlane(Plane.WorldXY, headFrame);
      headTransform = Transform.Multiply(
        Transform.Rotation(
        Math.PI * (0.1 * MaxSpeed / 150.0) * Velocity.Length / MaxSpeed,
        headFrame.YAxis,
        new Point3d(Position.X, Position.Y, 0.25)),
        headTransform);

      for (int i = 0; i < 9; i++)
      {
        MeshHead[i] = (Mesh) MeshHeadOriginal[i].DuplicateShallow();
        MeshHead[i].Transform(headTransform);
      }
    }


    public void PlaySound()
    {
      if (SoundStopwatch.Elapsed.TotalSeconds > 1.5)
      {
        Sounds[Random.Next(7)].Play();
        SoundStopwatch.Restart();
      }
    }


    public void DrawPreviewMeshes(IGH_PreviewArgs args)
    {
      Mesh rebelCrest = (Mesh) MeshRebelCrest.DuplicateShallow();
      rebelCrest.Rotate(stepCount * 0.1, Vector3d.ZAxis, Point3d.Origin);
      rebelCrest.Translate(Target.X, Target.Y, 0.003);

      args.Display.DrawMeshShaded(rebelCrest, MatRebelCrest);

      args.Display.DrawMeshShaded(MeshBody, MatBody);
      args.Display.DrawMeshShaded(MeshShadow[0], MatShadow[0]);
      args.Display.DrawMeshShaded(MeshShadow[1], MatShadow[1]);
      for (int i = 0; i < 9; i++)
        args.Display.DrawMeshShaded(MeshHead[i], MatHead[i]);
    }
  }



